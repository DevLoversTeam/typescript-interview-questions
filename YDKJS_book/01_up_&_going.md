# "Ви не знаєте JS" Кайл Сімпсон

## Книга перша - "Почніть та вдосконалюйтесь" (Up & Go)

### Зміст

<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
  <summary style="cursor: pointer; font-weight: bold; font-size: 1.2em; color: #333;  padding: 8px; border-radius: 5px;">
    Передмова
  </summary>
  <div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
    
Що останнє нове ви вивчили?

Можливо, це була іноземна мова, як-от італійська чи німецька. Або, можливо, це був графічний редактор, як-от Photoshop. Чи техніка приготування їжі, або деревообробка, чи комплекс вправ. Я хочу, щоб ви згадали те відчуття, коли ви нарешті зрозуміли: той момент осяяння. Коли все перейшло від розмитого до кришталево чіткого, коли ви опанували циркулярну пилку чи зрозуміли різницю між чоловічим і жіночим родом іменників у французькій мові. Як це відчувалося? Досить неймовірно, чи не так?

А тепер я хочу, щоб ви повернулися трохи далі у своїх спогадах, до моменту перед тим, як ви опанували свою нову навичку. Як ви почувалися тоді? Мабуть, було трохи лячно і, можливо, трохи дратувало, правда ж? Колись ми всі не знали того, що знаємо зараз, і це цілком нормально – всі ми з чогось починаємо. Вивчення нового матеріалу – це захоплива пригода, особливо якщо ви прагнете опанувати предмет ефективно.

Я викладаю багато початкових курсів з програмування. Студенти, які відвідують мої заняття, часто намагалися самостійно вивчати такі предмети, як HTML чи JavaScript, читаючи блоґи або копіюючи та вставляючи код, але їм не вдалося по-справжньому опанувати матеріал, який дозволив би їм писати код для досягнення бажаного результату. І оскільки вони не до кінця розуміють усі тонкощі певних тем програмування, вони не можуть писати потужний код чи налагоджувати власні розробки, бо насправді не розуміють, що відбувається.

Я завжди вірю в правильне викладання на своїх заняттях, тобто я навчаю веб-стандартів, семантичної розмітки, коду з належними коментарями та інших найкращих практик. Я висвітлюю предмет ґрунтовно, пояснюючи як і чому, замість того, щоб просто викидати код для копіювання та вставлення. Коли ви прагнете зрозуміти свій код, ви створюєте кращі роботи і стаєте кращими в тому, що робите. Код перестає бути просто вашою роботою, він стає вашим ремеслом. Саме тому я в захваті від "Почніть та вдосконалюйтесь". Кайл веде нас у глибоке занурення через синтаксис та термінологію, щоб дати чудовий вступ до JavaScript без зрізання кутів. Ця книга не ковзає по поверхні, а дійсно дозволяє нам по-справжньому зрозуміти концепції.

Адже недостатньо просто вміти копіювати фрагменти jQuery у свій вебсайт, так само як недостатньо навчитися відкривати, закривати та зберігати документ у Photoshop. Звісно, коли я вивчив кілька основ програми, я міг створювати та ділитися зробленим дизайном. Але без справжнього знання інструментів та того, що за ними стоїть, як я можу визначити сітку, або створити читабельну систему шрифтів, або оптимізувати графіку для використання в вебі. Те саме стосується JavaScript. Не знаючи, як працюють цикли, як визначати змінні чи що таке область видимості, ми не писатимемо найкращий код, на який здатні. Ми не хочемо погоджуватися на щось менше — це все-таки наше ремесло.

Чим більше ви стикаєтеся з JavaScript, тим зрозумілішим він стає. Слова на кшталт замикань, об'єктів та методів можуть здаватися вам зараз недосяжними, але ця книга допоможе цим термінам стати зрозумілими. Я хочу, щоб ви пам'ятали ті два відчуття – до і після вивчення чогось – коли починаєте читати цю книгу. Це може здаватися складним, але ви взяли цю книгу до рук, тому що розпочинаєте чудову подорож до вдосконалення своїх знань. "Почніть та вдосконалюйтесь" – це початок нашого шляху до розуміння програмування. Насолоджуйтесь моментами осяяння!

*—Jenn Lukas (http://jennlukas.com, @jennlukas),
Frontend consultant*
  </div>
</details>

<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
  <summary style="cursor: pointer; font-weight: bold; font-size: 1.2em; color: #333; padding: 8px; border-radius: 5px;">
    Вступ
  </summary>
  <div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">

Я впевнений, ви помітили, але "JS" у назві серії – це не абревіатура слів для лайки про JavaScript, хоча лаятися через дивацтва цієї мови – це те, з чим ми, мабуть, усі можемо себе ототожнити!

Від найперших днів Вебу JavaScript був фундаментальною технологією, що керує інтерактивним досвідом навколо контенту, який ми споживаємо. Хоча JavaScript починався з мерехтливих слідів від миші та надокучливих спливаючих вікон, майже два десятиліття потому технологія та можливості JavaScript зросли на багато порядків, і мало хто сумнівається в його важливості в самому серці найдоступнішої програмної платформи світу: Вебу.

Але як мова програмування, вона постійно була мішенню для численної критики, частково через своє походження, але ще більше через свою філософію проєктування. Навіть сама назва викликає, як одного разу висловився Брендан Айк, статус "тупого молодшого брата" поруч з його більш зрілим старшим братом, Java. Але ця назва – лише випадковість політики та маркетингу. Ці дві мови надзвичайно різні в багатьох важливих аспектах. "JavaScript" настільки ж пов'язаний з "Java", як "карнавал" з "каром".

Оскільки JavaScript запозичує концепції та синтаксичні ідіоми з кількох мов, включаючи горді процедурні корені в стилі C, а також витончені, менш очевидні функціональні корені в стилі Scheme/Lisp, він надзвичайно доступний для широкої аудиторії розробників, навіть тих, хто має мало або взагалі не має досвіду програмування. "Hello World" у JavaScript настільки простий, що мова є привабливою та легкою для освоєння при першому знайомстві.

Хоча JavaScript, можливо, є однією з найпростіших мов для початку роботи, його особливості роблять ґрунтовне опанування мови значно рідшим явищем, ніж у багатьох інших мовах. Якщо для написання повномасштабної програми потрібне досить глибоке знання такої мови, як C чи C++, то повномасштабна продакшн-розробка на JavaScript може, і часто так і відбувається, лише поверхнево торкатися можливостей мови.

Складні концепції, що глибоко вкорінені в мову, натомість зазвичай проявляють себе в начебто спрощений спосіб, як-от передача функцій як зворотних викликів, що заохочує розробника JavaScript просто використовувати мову як є і не надто перейматися тим, що відбувається під капотом.

Це одночасно проста, легка у використанні мова, що має широку привабливість, та складна й нюансована сукупність мовних механізмів, які без ретельного вивчення вислизають від справжнього розуміння навіть для найдосвідченіших JavaScript-розробників.

У цьому й полягає парадокс JavaScript, ахіллесова п'ята мови, виклик, який ми зараз розглядаємо. Оскільки JavaScript можна використовувати без розуміння, справжнє розуміння мови часто так і не досягається.

### Місія

Якщо щоразу, коли ви натрапляєте на несподіванку чи розчарування в JavaScript, ваша реакція – додати це до чорного списку (як дехто звик робити), ви скоро будете обмежені лише порожньою оболонкою багатства JavaScript.

Хоча цей підмножина славнозвісно названа "Хорошими частинами" (The Good Parts), я б благав вас, шановний читачу, натомість розглядати її як "Легкі частини", "Безпечні частини" чи навіть "Неповні частини".

Ця серія "Ви не знаєте JS" пропонує протилежний виклик: вивчити та глибоко зрозуміти весь JavaScript, включно й особливо "Складні частини".

Тут ми безпосередньо розглядаємо тенденцію JavaScript-розробників вчити рівно стільки, щоб справлятися з роботою, ніколи не змушуючи себе дізнатися точно, як і чому мова поводиться саме так. Більше того, ми відкидаємо поширену пораду відступати, коли шлях стає складним.

Я не задовольняюся, і ви не повинні задовольнятися тим, щоб зупинятися, коли щось просто працює, не розуміючи чому. Я м'яко закликаю вас вирушити цим вибоїстим "менш второваним шляхом" і прийняти все, чим є і що може робити JavaScript. З цими знаннями жодна техніка, жоден фреймворк і жоден популярний модний акронім тижня не буде поза межами вашого розуміння.

Кожна з цих книг розглядає конкретні базові частини мови, які найчастіше неправильно розуміють або недостатньо розуміють, і занурюється в них глибоко та вичерпно. Після прочитання ви повинні набути твердої впевненості у своєму розумінні не лише теоретичних аспектів, а й практичних  моментів, які "потрібно знати".

JavaScript, який ви знаєте зараз, ймовірно, складається з частин, переданих вам іншими, які обпеклися через неповне розуміння. Цей JavaScript – лише тінь справжньої мови. Ви ще не справді знаєте JavaScript, але якщо ви заглибитеся в цю серію, то пізнаєте. Читайте далі, мої друзі. JavaScript чекає на вас.

### Огляд

JavaScript - чудовий. Його легко вивчити частково, і набагато складніше вивчити повністю (чи навіть достатньо). Коли розробники стикаються з незрозумілими моментами, вони зазвичай звинувачують мову замість свого нерозуміння. Ці книги мають на меті це виправити, надихаючи на глибоку повагу до мови, яку ви тепер можете і повинні ґрунтовно знати.

**Примітка:** *Багато прикладів у цій книзі розраховані на сучасні (та орієнтовані на майбутнє) середовища рушіїв JavaScript, такі як ES6. Деякий код може не працювати так, як описано, якщо запускати його на старіших (до-ES6) рушіях.*

### Умовні позначення, що використовуються в цій книзі

У цій книзі використовуються такі типографічні умовності:

*Курсив*

Позначає нові терміни, URL-адреси, електронні адреси, назви файлів і розширення файлів.

`Моноширинний шрифт`

Використовується для програмного коду, а також у межах абзаців для позначення елементів програми, таких як назви змінних чи функцій, бази даних, типи даних, змінні середовища, оператори та ключові слова.

**`Моноширинний жирний`**

Показує команди чи інший текст, який користувач повинен вводити дослівно.

*`Моноширинний курсив`*

Показує текст, який має бути замінений значеннями, що надає користувач, або значеннями, які визначаються контекстом.

  </div>
</details>


<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.2em; color: #333; padding: 8px; border-radius: 5px;">
    РОЗДІЛ 1
</summary>

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">

  ### Введення в програмування

Ласкаво просимо до серії книг "Ви не знаєте JS" (YDKJS).

"Почніть та вдосконалюйтесь" є вступом до кількох базових концепцій програмування – звісно, ми схиляємося конкретно до JavaScript (часто скорочується як JS) – і того, як підходити до розуміння решти книг цієї серії. Особливо якщо ви тільки починаєте знайомитися з програмуванням та/або JavaScript, ця книга коротко розгляне все, що вам потрібно для початку роботи.

Ця книга починається з пояснення базових принципів програмування на дуже високому рівні. Вона здебільшого призначена для тих, хто починає вивчення YDKJS з невеликим досвідом програмування або взагалі без нього, і розглядає ці книги як допомогу в розумінні програмування через призму JavaScript.

Якщо ви вже досить добре знайомі з JavaScript, спочатку погляньте на Розділ 3, щоб коротко ознайомитися з тим, чого очікувати від YDKJS, а потім сміливо починайте!

До Розділу 1 варто підходити як до швидкого огляду речей, які ви захочете вивчити глибше та попрактикувати для входження в програмування. Також існує багато інших чудових ресурсів для знайомства з програмуванням, які можуть допомогти вам глибше зануритися в ці теми, і я заохочую вас вчитися з них на додаток до цього розділу.

Коли ви почуватиметеся впевнено з загальними основами програмування, [Розділ 2](#section2) допоможе вам познайомитися з особливостями програмування на JavaScript. [Розділ 2](#section2) знайомить з тим, що таке JavaScript, але знову ж таки, це не вичерпний посібник – для цього існують інші книги серії YDKJS!

<!-- ================ subsection ================ -->


<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Код (Code)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">
Почнемо з початку.

Програма, яку часто називають вихідним кодом (source code) або просто кодом, – це набір спеціальних інструкцій, які вказують комп'ютеру, які завдання виконувати. Зазвичай код зберігається в текстовому файлі, хоча з JavaScript ви також можете вводити код безпосередньо в консоль розробника в браузері, про що ми поговоримо незабаром.

Правила для допустимого формату та комбінацій інструкцій називаються мовою програмування, іноді її називають синтаксисом, багато в чому так само, як англійська мова вказує вам, як писати слова та як створювати правильні речення, використовуючи слова та пунктуацію.

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Інструкції (Statements)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

У мові програмування група слів, чисел та операторів, що виконує конкретне завдання, називається інструкцією. У JavaScript інструкція може виглядати так:

```javascript
a = b * 2; 
``` 

Символи `a` та `b` називаються змінними *(variables)* (див. главу "Змінні"), які подібні до простих коробок, де ви можете зберігати будь-які свої речі. У програмах змінні *(variables)* містять значення (наприклад, число `42`), які програма буде використовувати. Думайте про них як про символічні заповнювачі для самих значень.

Натомість, `2` – це просто саме значення, яке називається літеральним значенням *(literal value)*, оскільки воно існує самостійно, не зберігаючись у змінній.
Символи `=` та `*` – це оператори (див. главу "Оператори") – вони виконують дії зі значеннями та змінними, такі як присвоєння та математичне множення.

Більшість інструкцій у JavaScript завершуються крапкою з комою (`;`) в кінці.

Інструкція `a = b * 2;` приблизно каже комп'ютеру отримати поточне значення, що зберігається в змінній `b`, помножити це значення на `2`, потім зберегти результат в іншу змінну, яку ми називаємо `a`.

Програми – це просто набори багатьох таких інструкцій, які разом описують усі кроки, необхідні для виконання призначення вашої програми.

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
Вирази (Expressions)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

Інструкції *(Statements)* складаються з одного або декількох виразів *(Expressions)*. Вираз – це будь-яке посилання на змінну чи значення, або набір змінних та значень, поєднаних операторами. 

Наприклад:
```javascript
a = b * 2;
``` 

Ця інструкція містить чотири вирази:

- `2` – це вираз літерального значення.
- `b` – це вираз змінної, що означає отримання її поточного значення.
- `b * 2` – це арифметичний вираз, який означає виконання множення.
- `a = b * 2` – це вираз присвоєння, який означає присвоєння результату виразу `b * 2` змінній a (детальніше про присвоєння пізніше).

Загальний вираз, що стоїть окремо, також називається виразом-інструкцією, наприклад:

```javascript
b * 2;
```

Такий тип виразу-інструкції не є дуже поширеним чи корисним, оскільки зазвичай він не матиме жодного впливу на виконання програми – він отримає значення `b` і помножить його на `2`, але потім нічого не зробить з цим результатом.

Більш поширеним виразом-інструкцією є інструкція виклику функції *(див. главу "Функції")*, де вся інструкція є власне виразом виклику функції:

```javascript
alert( a );
```

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
Виконання програми (Executing a Program)

</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

Як ці набори програмних інструкцій повідомляють комп'ютеру, що робити? Програму потрібно виконати *(execute)*, що також називають запуском програми *(running a program)*.

Інструкції на кшталт `a = b * 2` корисні для розробників під час читання та написання коду, але вони не є у формі, яку комп'ютер може безпосередньо зрозуміти. Тому спеціальна утиліта на комп'ютері (інтерпретатор або компілятор) використовується для перекладу написаного вами коду в команди, зрозумілі комп'ютеру.

Для деяких мов програмування цей переклад команд зазвичай виконується згори донизу, рядок за рядком, щоразу, коли програма запускається, що зазвичай називають інтерпретацією коду.

Для інших мов переклад виконується заздалегідь, що називається компіляцією коду, тому коли програма запускається пізніше, виконуються вже скомпільовані комп'ютерні інструкції, готові до роботи.

Зазвичай стверджують, що JavaScript є інтерпретованою мовою, оскільки ваш вихідний код JavaScript обробляється щоразу під час його запуску. Але це не зовсім точно. Рушій JavaScript насправді компілює програму на льоту і потім одразу виконує скомпільований код.

**Примітка:** *Для отримання детальнішої інформації про компіляцію JavaScript дивіться перші два розділи книги "Область Видимості та Замикання" (Scope & Closures) з цієї серії.*

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
Спробуйте самі (Try It Yourself)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

Цей розділ представить кожну концепцію програмування за допомогою простих фрагментів коду, написаних мовою JavaScript (звісно!).

Не можна достатньо наголосити: поки ви опрацьовуєте цей розділ – і вам, можливо, доведеться витратити час, щоб переглянути його кілька разів – вам слід практикувати кожну з цих концепцій, набираючи код самостійно. Найпростіший спосіб зробити це – відкрити консоль інструментів розробника у вашому браузері (Firefox, Chrome, IE тощо).        

**Примітка:** *Зазвичай ви можете запустити консоль розробника за допомогою комбінації клавіш або через пункт меню. Щоб отримати детальнішу інформацію про запуск та використання консолі у вашому улюбленому браузері, дивіться розділ "Опанування консолі інструментів розробника" (Mastering The Developer Tools Console). Щоб ввести кілька рядків у консоль одночасно, використовуйте <shift> + <enter> для переходу на новий рядок. Коли ви натиснете <enter> окремо, консоль виконає все, що ви щойно ввели.*

Давайте ознайомимося з процесом виконання коду в консолі. Спочатку я пропоную відкрити порожню вкладку у вашому браузері. Я надаю перевагу робити це, ввівши about:blank в адресний рядок. Потім переконайтеся, що ваша консоль розробника відкрита, як ми щойно зазначали. Тепер введіть цей код і подивіться, як він виконується:

```javascript
a = 21;
b = a * 2;
console.log( b );
```
Введення наведеного вище коду в консоль Chrome має видати щось на кшталт такого результату: `42`

![screenshot](../assets/01_01.png)

Спробуйте! Найкращий спосіб вивчити програмування – це почати писати код!


### Input (Виведення)

У попередньому фрагменті коду ми використали `console.log(..)`. Давайте коротко розглянемо, що означає цей рядок коду.

Ви, можливо, здогадалися, але саме так ми виводимо текст (тобто виводимо дані для користувача) в консолі розробника. В цій інструкції є дві характеристики, які ми маємо пояснити.

По-перше, частина `log( b )` називається викликом функції (див. главу "Функції"). Відбувається те, що ми передаємо змінну `b` цій функції, яка бере значення `b` і виводить його в консоль.

По-друге, частина `console.` є посиланням на об'єкт, де розташована функція log(..). Ми розглянемо об'єкти та їхні властивості детальніше в [Розділі 2](#section2).

Інший спосіб створення виведення, яке ви можете побачити – це виконати інструкцію `alert(..)`. 

Наприклад:

```javascript
alert( b );
```

Якщо ви це виконаєте, то помітите, що замість виведення в консоль, з'явиться спливаюче вікно `"OK"` зі вмістом змінної `b`. 

Проте використання `console.log(..)` зазвичай полегшує вивчення програмування та виконання ваших програм у консолі порівняно з `alert(..)`, оскільки ви можете виводити багато значень одночасно, не перериваючи роботу інтерфейсу браузера. У цій книзі ми використовуватимемо `console.log(..)` для виведення.


### Введення (Input)

Поки ми обговорюємо виведення, ви також можете поцікавитися введенням *(input)* (тобто отриманням інформації від користувача).

Найпоширеніший спосіб – це показати на HTML-сторінці елементи форми (наприклад, текстові поля), в які користувач може вводити дані, а потім використовувати JS для зчитування цих значень у змінні вашої програми.

Але для простого навчання та демонстраційних цілей, якими ви займатиметесь протягом цієї книги, існує простіший спосіб отримання введення. Використовуйте функцію `prompt(..)`:

```javascript
age = prompt( "Please tell me your age:" );
console.log( age );
```
Як ви могли здогадатися, повідомлення, яке ви передаєте в`prompt(..)` – у цьому випадку `"Please tell me your age:"` – виводиться у спливаючому вікні.

Це має виглядати приблизно так:

![Screenshot](../assets/01_02.png)

Після того, як ви відправите введений текст, натиснувши *"OK"*, ви побачите, що введене вами значення зберігається в змінній `age`, яку ми потім виводимо за допомогою `console.log(..)`.

![Screenshot](../assets/01_03.png)

Щоб зберегти простоту під час вивчення основних концепцій програмування, приклади в цій книзі не вимагатимуть введення даних. Але тепер, коли ви побачили, як використовувати `prompt(..)`, якщо хочете випробувати себе, ви можете спробувати використовувати введення даних у своїх експериментах з прикладами.

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Оператори (Operators)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

Оператори - це те, як ми виконуємо дії над змінними та значеннями. Ми вже бачили два оператори JavaScript: `=` та `*`.
Оператор `*` виконує математичне множення. Досить просто, правда?
Оператор `=` (дорівнює) використовується для присвоєння – спочатку ми обчислюємо значення з правого боку (вихідне значення) від `=`, а потім поміщаємо його в змінну, яку ми вказуємо з лівого боку (цільова змінна).

**Примітка:** *Такий порядок присвоєння може здатися дивним. Замість `a = 42`, дехто міг би віддати перевагу зворотному порядку, де вихідне значення зліва, а цільова змінна справа, як-от `42 ->` a (це не валідний JavaScript!). На жаль, форма `a = 42` та подібні варіації досить поширені в сучасних мовах програмування. Якщо це здається неприродним, просто витратьте деякий час на повторення цього порядку подумки, щоб звикнути.*

Розглянемо:

```javascript
a = 2;
b = a + 1;
```

Тут ми присвоюємо значення `2` змінній `a`. Потім ми отримуємо значення змінної a (все ще 2), додаємо до нього `1`, отримуючи значення `3`, а потім зберігаємо це значення в змінній `b`.

Хоча технічно це не оператор, вам знадобиться ключове слово `var` у кожній програмі, оскільки це основний спосіб оголошення (тобто створення) змінних (див. главу "Змінні").

Ви завжди повинні оголошувати змінну за іменем перед її використанням. Але вам потрібно оголосити змінну лише один раз для кожної області видимості (див. главу "Область видимості"); після цього її можна використовувати стільки разів, скільки потрібно. Наприклад:

```javascript
var a = 20;
a = a + 1;
a = a * 2;

console.log( a ); // 42
```

Ось деякі з найпоширеніших операторів у JavaScript:

**Присвоєння *(Assignment)***

`=`, як у `a = 2`.

**Математичні *(Math)***

`+` додавання *(addition)*, `-` віднімання *(substraction)*, `*` множення *(multiplication)* та `/`  ділення *(division)*, як у `a * 3`.


**Складене присвоєння *(Compound assignment)***

`+=`, `-=`, `*=`, та `/=` - це складені оператори, які поєднують математичну операцію з присвоєнням, як у `a += 2` (те саме, що й `a = a + 2`).

**Інкремент/декремент *(Increment/decrement)***

`++` (інкремент), `--` (декремент), як у `a++` (подібно до `a = a + 1`).

**Доступ до властивостей об'єкта *(Object property access)***

`.` як у `console.log()`.

Об'єкти - це значення, які містять інші значення в певних іменованих місцях, які називаються властивостями. obj.a означає об'єктне значення під назвою obj з властивістю з іменем a. До властивостей також можна отримати доступ як `obj["a"]`. Див. [Розділ 2](#section2).

**Рівність *(Equality)***

`==` нестрога рівність *(loose-equals)* , `===` строга рівність *(strict-equals)*, `!=` нестрога нерівність *(loose not-equals)*, `!==` строга нерівність *(strict not-equals)*, як у `a == b` (див. "Значення і типи" та [Розділ 2](#section2)).

**Порівняння *(Comparison)***

`<` менше *(less than)*, `>` більше *(greater than)*, `<=` менше або нестрого дорівнює *(less than or loose-equals)*, `>=` більше або нестрого дорівнює *(greater than or loose-equals)*, як у `a <= b` (див. "Значення і типи" та [Розділ 2](#section2)).

**Логічні *(Logical)***

`&&` "і" (and), `||` "або" (or), як у `a || b`, що вибирає або `a` або `b`.
Ці оператори використовуються для вираження складених умов (див. "Умовні конструкції"), наприклад, якщо істинне або `a`, або `b`.

**Примітка:** *Для отримання більш детальної інформації та огляду операторів, не згаданих тут, дивіться ["Вирази та оператори" (Expressions and Operators)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators) в Mozilla Developer Network (MDN).*


</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details id="values" style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Значення та типи (Values & Types)
</summary>
<div  style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

Якщо ви запитаєте працівника магазину телефонів, скільки коштує певний телефон, і він відповість "дев'яносто дев'ять, дев'яносто дев'ять" (тобто 99,99 грн), він надає вам числове значення у гривнях, яке представляє суму, яку вам потрібно заплатити (плюс податки) для придбання цього телефону. Якщо ви бажаєте придбати два таких телефони, ви можете легко провести розрахунок у розумі, подвоївши це значення, і отримати 199,98 грн як базову вартість.
Якщо той самий працівник візьме інший схожий телефон і скаже, що він "безкоштовний" (можливо, з жестом лапок у повітрі), він не надає вам числа, а інший тип представлення очікуваної вартості (0,00 грн) — слово "безкоштовний".
Коли пізніше ви запитаєте, чи входить до комплекту зарядний пристрій, відповідь може бути лише "так" або "ні".
Аналогічним чином, коли ви виражаєте значення у програмах, ви обираєте різні представлення для цих значень залежно від того, що плануєте з ними робити.
Ці різні представлення значень називаються *типами* в термінології програмування. JavaScript має вбудовані типи для кожного з цих так званих *примітивних* значень:

- Коли вам потрібно виконувати математичні операції, ви використовуєте число `number`.
- Коли вам потрібно вивести значення на екран, вам потрібен рядок `string` (один або більше символів, слів чи речень).
- Коли вам потрібно прийняти рішення у вашій програмі, вам потрібен логічний тип `boolean (true або false)`.

Значення, які включені безпосередньо у вихідний код, називаються літералами. Рядкові літерали оточені подвійними лапками `("...")` або одинарними лапками `('...')` — єдина різниця полягає у стилістичній перевазі. Числові та логічні літерали представлені як є (наприклад, `42`, `true` тощо).

Розглянемо:

```javascript
"Я є рядок"; 
'Я також є рядок';
 42; 
 true; 
 false;
``` 

Окрім типів значень `рядок` *(string)*/`число` *(number)*/`логічний` *(boolean)*, для мов програмування звичайно надавати масиви, об'єкти, функції тощо. Ми розглянемо набагато більше про значення та типи протягом цього та наступного розділів.

 ### Перетворення між типами (Converting Between Types)

Коли у вас є число, але вам потрібно відобразити його на екрані, необхідно перетворити це значення на рядок. У JavaScript таке перетворення називається "приведенням типів" або "коерцією" (coercion). Аналогічно, якщо користувач вводить послідовність цифрових символів у формі на сторінці електронної комерції, це буде рядок, але якщо вам потрібно виконати з цим значенням математичні операції, необхідно привести його до числового типу.
JavaScript надає декілька різних механізмів для примусового перетворення між *типами*. Наприклад:

```javascript
var a = "42";

var b = Number( a );

console.log( a ); // "42"
console.log( b ); // 42
``` 

Використання `Number(..)` (вбудованої функції), як показано вище, є явним приведенням типів *(explicit coercion)* з будь-якого іншого типу до числового типу. Це має бути досить зрозуміло.

Однак суперечливою темою є те, що відбувається, коли ви намагаєтесь порівняти два значення, які початково мають різні типи, що вимагатиме неявного приведення типів *(implicit coercion)*.

Коли порівнюємо рядок `"99.99"` з числом `99.99`, більшість людей погодяться, що вони еквівалентні. Але вони не є абсолютно однаковими, чи не так? Це одне й те саме значення в двох різних представленнях, двох різних типах. Можна сказати, що вони "нестрого рівні" *(loosely equal)*, чи не так?

Для спрощення роботи в поширених ситуаціях JavaScript іноді автоматично активує механізм неявного приведення значень до відповідних типів.

Якщо ви використовуєте оператор нестрогої рівності *(loose-equals)* `==` для порівняння `"99.99" == 99.99`, JavaScript перетворить лівий операнд `"99.99"` до його числового еквівалента 99.99. Порівняння трансформується у 99.99 == 99.99, що, звісно, є істинним.

Хоча неявне приведення типів було розроблено для зручності, воно може створювати плутанину, якщо ви не приділили час вивченню правил, що регулюють його поведінку. Більшість розробників JavaScript ніколи цього не робили, тому поширене відчуття, що неявне приведення типів є заплутаним і шкодить програмам, створюючи неочікувані помилки, а тому його слід уникати. Іноді його навіть називають недоліком у дизайні мови.

Однак, неявне приведення типів – це механізм, який можна вивчити, і більше того, повинен бути вивчений кожним, хто бажає серйозно займатися програмуванням на JavaScript. Коли ви засвоїте правила, воно не лише перестане бути заплутаним, але й може фактично покращити ваші програми! Докладені зусилля того варті.

**Примітка:** *Для отримання додаткової інформації щодо приведення типів, зверніться до [Розділу 2](#section2) цієї книги та Розділу 4 книги "Типи та Синтаксис" (Types $ Grammar) з цієї ж серії.*

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
       Коментарі в коді (Code Comments)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">
        
Працівник магазину телефонів може робити нотатки про характеристики нового пристрою чи про тарифні плани, які пропонує компанія. Ці нотатки призначені виключно для працівника — вони не для читання клієнтами. Тим не менш, ці примітки допомагають працівникові краще виконувати свою роботу, документуючи способи та причини того, що він повинен повідомляти клієнтам.

Один із найважливіших уроків, який можна засвоїти про написання коду — він призначений не лише для комп'ютера. Код настільки ж важливий, якщо не більше, для розробника, як і для компілятора.

Ваш комп'ютер цікавиться лише машинним кодом — послідовністю двійкових 0 та 1, що отримується після компіляції. Існує майже нескінченна кількість програм, які ви могли б написати для отримання однієї й тієї ж послідовності 0 та 1. Вибір, який ви робите щодо того, як писати програму, має значення — не лише для вас, але й для інших членів вашої команди і навіть для вас у майбутньому.

Вам слід прагнути не просто писати програми, які правильно працюють, а програми, які мають сенс при аналізі. Ви можете значно просунутися в цьому напрямку, обираючи хороші імена для змінних (див. "Змінні") та функцій (див. "Функції").

Але іншою важливою частиною є коментарі в коді. Це фрагменти тексту у вашій програмі, які включені виключно для пояснення процесів людині. Інтерпретатор/компілятор завжди ігноруватиме ці коментарі.

Існує багато думок щодо того, що робить код добре прокоментованим; ми не можемо визначити абсолютні універсальні правила. Однак деякі спостереження та рекомендації є досить корисними:

- Код без коментарів є субоптимальним.
- Занадто багато коментарів (наприклад, один на рядок) ймовірно є ознакою погано написаного коду.
- Коментарі повинні пояснювати чому, а не що. Вони можуть додатково пояснювати як, якщо написане є особливо заплутаним.

У JavaScript можливі два типи коментарів: однорядковий коментар та багаторядковий коментар.

Приклад:
```javascript
// Це однорядковий коментар

/* А це багаторядковий коментар. */
``` 
Однорядковий коментар `//` оптимальний для розміщення безпосередньо над окремою інструкцією або в кінці рядка коду. Усі символи після `//` інтерпретуються як коментар (та ігноруються компілятором) до кінця рядка. Важливо зазначити, що не існує обмежень щодо вмісту однорядкового коментаря.

Приклад:
```javascript
var a = 42; // 42 - це відповідь на питання життя, всесвіту і всього іншого
```

Багаторядковий коментар `/* .. */` доцільно використовувати, коли ваше пояснення займає кілька рядків.

Типовий варіант використання багаторядкових коментарів:
```javascript
/* 
 * Наступне значення використовується, оскільки було 
 * доведено, що воно відповідає на кожне питання всесвіту. 
 */

var a = 42;
```

Коментарі можуть з'являтися будь-де в рядку коду, навіть посередині. Наприклад:

```javascript
var a = /* довільне значення */ 42; 
console.log( a ); // 42
```

Єдине обмеження — всередині багаторядкового коментаря не може бути послідовності /, оскільки вона буде інтерпретована як закінчення коментаря.

Ви неодмінно захочете розпочати вивчення програмування з формування звички коментування коду. Впродовж решти розділу ви побачите, як я використовую коментарі для пояснення речей, тому робіть те саме у власній практиці. Повірте мені, кожен, хто читатиме ваш код, буде вам вдячний!

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Змінні (Variables)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

Більшість корисних програм повинні відстежувати значення, яке змінюється впродовж виконання програми, зазнаючи різних операцій відповідно до передбачених завдань.

Найпростіший спосіб зробити це — призначити значення символічному контейнеру, який називається змінною *(variable)*, — і названий так тому, що значення в цьому контейнері може змінюватися з часом за потреби.

У деяких мовах програмування змінну (контейнер) оголошують для зберігання певного типу значення, наприклад числа або рядка. Статична типізація *(Static Typing)*, відома також як примусова типізація *(Type Enforcement)*, зазвичай розглядається як перевага для коректності програми, оскільки запобігає непередбаченим перетворенням значень.

Інші мови акцентують типи значень замість змінних. Слабка типізація *(Weak typing)*, відома як динамічна типізація *(dynamic typing)*, дозволяє змінній зберігати будь-який тип значення будь-коли. Це зазвичай розглядається як перевага для гнучкості програми, оскільки дозволяє одній змінній представляти значення незалежно від форми типу в будь-який момент логічного потоку програми.

JavaScript використовує другий підхід — динамічну типізацію *(dynamic typing)*, що означає: змінні можуть містити значення будь-якого типу без будь-якого примусу типів. Як згадувалося раніше, ми оголошуємо змінну за допомогою оператора `var` — зверніть увагу, що в оголошенні немає жодної додаткової інформації про тип. 

Розгляньмо цю просту програму:
```javascript
var amount = 99.99;

amount = amount * 2;
console.log( amount ); // 199.98

// перетворити `amount` на рядок і додати "$" на початок
amount = "$" + String( amount );

console.log( amount ); // "$199.98"
```

Змінна `amount` спочатку містить число `99.99`, потім результат операції amount `* 2`, тобто `199.98`.

Перша команда `console.log(..)` має неявно перетворити числове значення на рядок для друку.

Потім інструкція `amount = "$" + String(amount)` явно перетворює значення `199.98` на рядок і додає символ `"$"` на початок. Тепер amount містить рядкове значення `"$199.98"`, тому друга команда `console.log(..)` не потребує жодного перетворення для друку.

Розробники JavaScript оцінять гнучкість використання змінної amount для значень `99.99`, `199.98` та `"$199.98"`. Прихильники статичної типізації волліли б мати окрему змінну на кшталт amountStr для зберігання кінцевого рядкового представлення `"$199.98"`, оскільки це інший тип.

Так чи інакше, варто зазначити, що `amount` містить поточне значення, яке змінюється впродовж виконання програми, що ілюструє основну мету змінних: керування станом програми.

Іншими словами, стан *(state)* — це відстеження змін значень під час виконання програми.

Інше поширене використання змінних — централізація встановлення значень. Це здебільшого називають константами *(constants)*, коли ви оголошуєте змінну зі значенням і маєте намір, щоб це значення не змінювалося впродовж програми.

Ви оголошуєте такі константи, часто на початку програми, щоб було зручно змінити значення в одному місці за потреби. За домовленістю, змінні JavaScript як константи зазвичай пишуться великими літерами, з підкресленнями _ між словами.

Ось простий приклад:
```javascript
var TAX_RATE = 0.08; // 8% податку з продажу
var amount = 99.99;

amount = amount * 2;
amount = amount + (amount * TAX_RATE);

console.log( amount ); // 215.9784
console.log( amount.toFixed( 2 ) ); // "215.98"
```

**Примітка:** *Подібно до того, як `console.log(..)` є функцією `log(..)`, доступною як властивість об'єкта `console`, `toFixed(..)` є функцією, яку можна викликати на числових значеннях. Числа JavaScript не форматуються автоматично як долари — рушій не знає вашого наміру, і немає типу для валюти. `toFixed(..)` дозволяє вказати, скільки десяткових знаків ми хочемо заокруглити, і він створює рядок за потреби.*

Змінна TAX_RATE є константою лише за домовленістю — в цій програмі немає нічого особливого, що перешкоджало б її зміні. Але якщо місто підвищить ставку податку до 9%, ми все ще можемо легко оновити нашу програму, встановивши призначене значення TAX_RATE на `0.09` в одному місці, замість того, щоб шукати багато входжень значення `0.08` по всій програмі та оновлювати їх.

Найновіша версія JavaScript на момент написання (зазвичай звана "ES6") включає новий спосіб оголошення констант — використання `const` замість `var`:

```javascript
// з ES6:
const TAX_RATE = 0.08;

var amount = 99.99;
// ..
```

Константи корисні так само, як і незмінні змінні, за винятком того, що константи також запобігають випадковій зміні значення після початкове налаштування. Якщо ви спробуєте призначити будь-яке інше значення TAX_RATE після первинного оголошення, ваша програма відхилить зміну, а в строгому режимі — видасть помилку — (див. "Строгий режим" у [Розділі 2](#section2)).

До речі, такий "захист" від помилок подібний до примусової типізації статичних типів, тому можна зрозуміти, чому статичні типи в інших мовах можуть бути привабливими!

**Примітка:** *Для отримання додаткової інформації про те, як різні значення у змінних можуть використовуватися в ваших програмах, дивіться книгу  "Типи та Синтаксис" (Types & Grammar) цієї серії.*

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Блоки (Blocks)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

Співробітник телефонного магазину повинен пройти низку кроків, щоб завершити оформлення покупки вашого нового телефону.

Подібно до цього, в коді ми часто потребуємо групування низки інструкцій разом, що зазвичай називають блоком. У JavaScript блок визначається шляхом огортання однієї або кількох інструкцій всередину фігурних дужок `{ .. }`. 

Розглянемо:
```javascript
var amount = 99.99;

// загальний блок
{
    amount = amount * 2;
    console.log( amount ); // 199.98
}
```

Такий автономний `{ .. }` загальний блок є коректним, але не часто зустрічається в JS-програмах. Типово блоки приєднуються до інших керувальних інструкцій, наприклад, інструкції if (див. "Умовні оператори") або циклу (див. "Цикли"). 

Наприклад:
```javascript
var amount = 99.99;

// чи достатньо велика amount?
if (amount > 10) {
    amount = amount * 2; // <-- блок приєднаний до `if`
    console.log( amount ); // 199.98
}
```

Ми пояснимо інструкції if у наступному розділі, але як ви бачите, блок `{ .. }` з двома інструкціями приєднаний до if (amount > 10); інструкції всередині блоку будуть опрацьовані лише якщо умова пройде.

**Примітка:** *На відміну від більшості інших інструкцій, таких як `console.log(amount);`, блокова інструкція не потребує крапки з комою (;) для її завершення.* 

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Умовні оператори (Conditionals)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

"Бажаєте додати захисну плівку до вашої покупки за 9,99 доларів?" Люб'язний співробітник телефонного магазину пропонує вам прийняти рішення. І можливо, вам спершу доведеться перевірити стан вашого гаманця або банківського рахунку, щоб відповісти на це запитання. Але очевидно, що це просто просте питання "так чи ні".

Існує чимало способів виражати умовні оператори (тобто рішення) в наших програмах.

Найпоширеніший — інструкція `if`. По суті, ви кажете: "Якщо ця умова є правильною, зробіть наступне...". 

Наприклад:
```javascript
var bank_balance = 302.13;
var amount = 99.99;

if (amount < bank_balance) {
    console.log( "Я хочу купити цей телефон!" );
}
```

Інструкція `if` вимагає виразу між дужками `( )`, який може бути інтерпретований як `true` або `false`. У цій програмі ми надали вираз `amount < bank_balance`, який дійсно буде або `true`, або `false` залежно від суми на рахунку `bank_balance`.

Ви навіть можете передбачити альтернативу, якщо умова не є правильною, що називається `else`. 

Розглянемо:
```javascript

const ACCESSORY_PRICE = 9.99;
var bank_balance = 302.13;
var amount = 99.99;
amount = amount * 2;

// чи можемо ми дозволити додаткову покупку?
if ( amount < bank_balance ) {
    console.log( "Я куплю аксесуар!" );
    amount = amount + ACCESSORY_PRICE;
}
// інакше:
else {
    console.log( "Ні, дякую." );
}
```

Якщо `amount < bank_balance` є `true`, ми надрукуємо "Я куплю аксесуар!" і додамо 9,99 до змінної amount. Інакше інструкція else каже, що ми ввічливо відповімо "Ні, дякую." і залишимо amount незмінним.

Як ми обговорювали в розділі ["Значення та типи" *(Values & Types)*](#values), значення, які не є очікуваного типу, часто перетворюються на цей тип. Інструкція if очікує boolean, але якщо передати щось інше, відбудеться примусове перетворення.

JavaScript визначає список конкретних значень, які вважаються "хибними" *(falsy)*, оскільки при перетворенні на `boolean` вони стають `false` — це такі значення, як 0 та "". Будь-яке інше значення, не внесене до списку "хибних", автоматично є "правдивим" *(truthy)* — при перетворенні на boolean вони стають `true`. Правдиві значення включають такі, як `99,99` та `"free"`. Більше інформації дивіться в розділі "Правдиві та хибні значення" у Розділі 2.

Умовні оператори *(Conditionals)* існують й в інших формах, крім `if`. Наприклад, інструкція `switch` може використовуватися як скорочення для серії інструкцій `if..else` (див. [Розділ 2](#section2)). Цикли використовують умовний оператор, щоб визначити, чи має цикл продовжуватися або зупинитися.

**Примітка:** *Для детальнішої інформації про неявні перетворення, що можуть траплятися у тестових виразах умовних операторів, дивіться Розділ 4 книги "Типи та Синтаксис" (Types & Grammar) цієї серії.*

</div>
</details>
</div>

<!-- ================ subsection ================ -->


<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Цикли (Loops)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

У часи активної роботи є список очікування для клієнтів, які потребують спілкування з співробітником телефонного магазину. Доки в списку є люди, вона просто має продовжувати обслуговувати наступного клієнта.

Повторення набору дій до моменту, коли певна умова перестає бути правильною — іншими словами, повторення лише доки умова зберігається — є завданням циклів у програмуванні; цикли можуть мати різні форми, але всі вони задовольняють цю базову поведінку.

Цикл включає тестову умову та блок (типово у `{ .. }`). Кожного разу, коли виконується блок циклу, це називається ітерацією.

Наприклад, форми циклів `while` та `do..while` ілюструють концепцію повторення блоку інструкцій, доки умова більше не є правильною:

```javascript
while (numOfCustomers > 0) {
    console.log( "Чим я можу вам допомогти?" );

    // допомогти клієнту...

    numOfCustomers = numOfCustomers - 1;
}

// проти:

do {
    console.log( "Чим я можу вам допомогти?" );

    // допомогти клієнту...

    numOfCustomers = numOfCustomers - 1;
} while (numOfCustomers > 0);
```

Єдина практична різниця між цими циклами — чи тестується умова перед першою ітерацією (`while`), чи після першої ітерації (`do..while`).

У будь-якій формі, якщо умова тестується як `false`, наступна ітерація не запуститься. Це означає, що якщо умова спочатку `false`, цикл `while` ніколи не запуститься, але цикл `do..while` виконається один раз.

Інколи ви використовуєте цикл з метою підрахунку певного набору чисел, наприклад від 0 до 9 (10 чисел). Це можна зробити, встановивши змінну ітерації циклу на зразок i зі значенням 0 і збільшуючи її на 1 на кожній ітерації.

**Примітка**: *З різних історичних причин programming мови майже завжди рахують речі у режимі з нульовим індексом, тобто починаючи з 0, а не з 1. Якщо ви не звикли до такого способу мислення, це може здатися досить заплутаним спочатку. Присвятіть трохи часу практиці підрахунку, починаючи з 0, щоб звикнути до цього!*

Умова тестується на кожній ітерації, наче є неявна інструкція if всередині циклу.

Ми можемо використати інструкцію `break` JavaScript для зупинки циклу. Також можна помітити, що дуже легко створити цикл, який інакше біг би нескінченно без механізму переривання.

Проілюструємо:
```javascript
var i = 0;

// цикл `while..true` біг би нескінченно, так?
while (true) {
    // продовжити цикл?
    if (i <= 9) {
        console.log( i );
        i = i + 1;
    }
    // час зупинити цикл!
    else {
        break;
    }
}

// 0 1 2 3 4 5 6 7 8 9
```

Це не обов'язково практична форма, яку ви захочете використовувати для своїх циклів. Вона представлена тут лише для ілюстрації.
Хоча `while` (або `do..while`) може виконати завдання вручну, існує інша синтаксична форма, що називається циклом `for`, саме для цієї мети:

```javascript
for (var i = 0; i <= 9; i = i + 1) {
    console.log( i );
}

// 0 1 2 3 4 5 6 7 8 9
```
Як бачите, в обох випадках умова `i <= 9` є правильною для перших 10 ітерацій (i зі значеннями від 0 до 9) будь-якої форми циклу, але стає `false`, коли `i` дорівнює 10.

Цикл `for` має три частини: частину ініціалізації (`var i=0`), частину тестування умови (`i <= 9`) та частину оновлення (`i = i + 1`). Тому, якщо ви збираєтеся здійснювати підрахунок в ітераціях циклу, `for` є більш компактною та часто простішою формою для розуміння і написання.

Існують інші спеціалізовані форми циклів, призначені для ітерації за конкретними значеннями, наприклад властивостями об'єкта (див. [Розділ 2](#section2)), де неявний тест умови — це просто чи всі властивості були опрацьовані. Концепція "циклу до моменту, коли умова не стане `false`", залишається незмінною, незалежно від форми циклу.

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Функції (Functions)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

Співробітник телефонного магазину, напевно, не носить із собою калькулятор, щоб порахувати податки та остаточну вартість покупки. Це завдання, яке він повинен визначити один раз і перевикористовувати знову і знову. Напевно, компанія має реєстратор (комп'ютер, планшет тощо) з вбудованими такими "функціями".

Подібно до цього, ваша програма майже напевно захоче розбити завдання коду на багаторазово використовувані шматки, замість того, щоб постійно повторюватися (гра слів навмисна!). Спосіб зробити це — визначити функцію.
Функція — це зазвичай іменована частина коду, яку можна "викликати" за ім'ям, і код всередині неї буде виконуватися щоразу. 

Розглянемо:
```javascript
function printAmount() {
    console.log( amount.toFixed( 2 ) );
}

var amount = 99.99;
printAmount(); // "99.99"

amount = amount * 2;
printAmount(); // "199.98"
```

Функції можуть необов'язково приймати аргументи (тобто параметри) — значення, які ви передаєте. І вони також можуть необов'язково повертати значення:
```javascript
function printAmount(amt) {
    console.log( amt.toFixed( 2 ) );
}

function formatAmount() {
    return "$" + amount.toFixed( 2 );
}

var amount = 99.99;
printAmount( amount * 2 ); // "199.98"

amount = formatAmount();
console.log( amount ); // "$99.99"
```
Функція `printAmount(..)` приймає параметр, який ми називаємо `amt`.

Функція `formatAmount()` повертає значення. Звісно, ви також можете поєднувати ці два прийоми в одній функції. 

Функції часто використовуються для коду, який ви плануєте викликати кілька разів, але вони також можуть бути корисними просто для організації пов'язаних шматків коду в іменовані колекції, навіть якщо ви плануєте викликати їх лише один раз. 

Розглянемо:
```javascript
const TAX_RATE = 0.08;

function calculateFinalPurchaseAmount(amt) {
    // порахувати нову суму з податком
    amt = amt + (amt * TAX_RATE);

    // повернути нову суму
    return amt;
}

var amount = 99.99;
amount = calculateFinalPurchaseAmount( amount );

console.log( amount.toFixed( 2 ) ); // "107.99"
```

Хоча `calculateFinalPurchaseAmount(..)` викликається лише один раз, організація його поведінки в окрему іменовану функцію робить код, що використовує його логіку (інструкція `amount = calculateFinal...`), чистішим. Якби функція мала більше інструкцій, переваги були б ще більш помітними.

</div>
</details>
</div>

<!-- ================ subsection ================ -->

<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Область видимості (Scope)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">

Якщо ви попросите співробітника телефонного магазину про модель телефону, яку його магазин не має, він не зможе вам її продати. Він має доступ лише до телефонів зі свого інвентарю. Вам доведеться спробувати інший магазин, щоб знайти бажаний телефон.

У програмуванні для цієї концепції є термін: область видимості *(scope)* (технічно — лексична область видимості *(lexical scope)*). У JavaScript кожна функція має власну область видимості. Область видимості — це по суті набір змінних та правил їхнього доступу за іменем. Лише код всередині функції може мати доступ до її змінних.

Ім'я змінної має бути унікальним в межах тієї самої області видимості — не може бути двох різних змінних a поруч. Але однакове ім'я змінної a може з'являтися в різних областях видимості:
```javascript
function one() {
    // ця `a` належить лише функції `one()`
    var a = 1;
    console.log( a );
}

function two() {
    // ця `a` належить лише функції `two()`
    var a = 2;
    console.log( a );
}

one(); // 1
two(); // 2
```
Також область видимості може бути вкладена в іншу область видимості, як якщо б клоун на дитячому святі роздував одну кульку всередині іншої. Якщо одна область видимості вкладена в іншу, код у найвнутрішнішій області може мати доступ до змінних з будь-якої області. 

Розглянемо:
```javascript
function outer() {
    var a = 1;

    function inner() {
        var b = 2;

        // ми можемо мати доступ до `a` та `b`
        console.log( a + b ); // 3
    }

    inner();

    // ми можемо мати доступ лише до `a`
    console.log( a ); // 1
}

outer();
```

Правила лексичної області видимості говорять, що код в одній області може мати доступ до змінних цієї або будь-якої зовнішньої області.

Отже, код всередині функції `inner()` має доступ до змінних `a` та `b`, але код лише в `outer()` має доступ лише до `a` — він не може мати доступ до `b`, оскількиця змінна лише всередині `inner()`.

Згадаймо цей уривок коду:
```javascript
const TAX_RATE = 0.08;

function calculateFinalPurchaseAmount(amt) {
    // порахувати нову суму з податком
    amt = amt + (amt * TAX_RATE);

    // повернути нову суму
    return amt;
}
```
Константа TAX_RATE доступна всередині функції `calculateFinalPurchaseAmount(..)`, хоча ми її не передавали, саме через лексичну область видимості.

**Примітка:** *Для детальнішої інформації про лексичну область видимості дивіться перші три розділи книги "Область Видимості і Замикання" (Scope & Closures)  цієї серії.*

</div>
</details>
</div>

<!-- ================ subsection ================ -->


<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Практика (Practice)
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">
        Текст розділу 

```javascript
console.log("HW")
``` 

</div>
</details>
</div>

<!-- ================ subsection ================ -->


<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Глава
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">
        Текст розділу 

```javascript
console.log("HW")
``` 

</div>
</details>
</div>

<!-- ================ subsection ================ -->


<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Глава
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">
        Текст розділу 

```javascript
console.log("HW")
``` 

</div>
</details>
</div>

<!-- ================ subsection ================ -->


<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
<summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Глава
</summary>
<div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">
        Текст розділу 

```javascript
console.log("HW")
``` 

</div>
</details>
</div>

<!-- ================ subsection ================ -->


  </div>
</details>


<details id="section2" style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
  <summary style="cursor: pointer; font-weight: bold; font-size: 1.2em; color: #333; padding: 8px; border-radius: 5px;">
    РОЗДІЛ 2
  </summary>
  <div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
    
  <div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
    <details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
      <summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Глава
      </summary>
  <div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">
        Текст глави


```javascript
console.log("HW")
``` 

  </div>
    </details>
  </div>

  </div>
</details>


<details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
  <summary style="cursor: pointer; font-weight: bold; font-size: 1.2em; color: #333; padding: 8px; border-radius: 5px;">
    РОЗДІЛ 3
  </summary>

  <div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
    
  <div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: #000">
    <details style="border: 1px solid #ccc; border-radius: 5px; margin-bottom: 10px; padding: 10px; background-color: #f9f9f9;">
      <summary style="cursor: pointer; font-weight: bold; font-size: 1.1em; color: #333; padding: 8px; border-radius: 5px;">
        Глава
      </summary>
  <div style="margin-top: 10px; padding: 10px; border-top: 1px solid #ccc; color: fff; color: #000">
        Текст глави


```javascript
console.log("HW")
``` 

  </div>
    </details>
  </div>

  </div>
</details>